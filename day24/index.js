const sample = `#.####################################################################################################
#<v>v>v><>^<>^.^vv<>><>>v.>v<.v>>v<<v<.^<>>>v<v^>.^<^>v>^<^v.^>v^>>><v<>v^<v<<^^.vv>.^>v>v<.^v<><v<>>#
#>>v<^<>vvv.>^.v^^>^<<vv>>v.<^<>v^<v^>v^<>>.v.^<<v^.^v^v><<.^vv<^<^v>.vvv<v>.<>>^>.<<<<<<.<^^<v.<>.v<#
#<<<>^^>>>>.v^>v<>^>^^v>v^^v..v^.<<^>^>.>v^^vv.<>>^><<>v.<v<^^<<v^v<.>^>v<>^^<<>v<<^^><vv>vv<<^^...^>#
#>>v><><<<^<.>v^<<v^>v^^<>>v<<>>.<>v><^<^<.^<><^^^vv>><v<v>vv>^>v^>>vv>><<v^<><>^v.vv>^<^<>v<vvvv^v><#
#<^<^>v^^<>>^<.^^>^vv><v<^^^.v^>><v^>v^.>>v^<..>>.v>v<v^^<.v<<^v<<>v.^>><>v<<>.^<<<<<>>>^<><v>><^>>v>#
#>v>^^^v<v^.>^>^>v>>>v>v<v^v^<v>>><<>v..>>vvv<^><<>>^^.>v^<^>>.^v><v<^<.^>>vv<v^<^vv^<<<^><v.>v<^<.v>#
#>v^>>v^<^<<^<v>..<.v^<.<><>v>v^<.><<<<^><<.<><><><.<.^.>^v^><<<vv.<>vvv<v^v.<^<>>>^>v<^v^<><><v>.^><#
#<><>>vv..<v^vv><^v^.^^vv.^>^>>v<>vv>^><<<><^vvv>>><>><>>^^<v<><^^v^^>.^>^<.<<^..v<v>v^>^v^v<<.v^<v<>#
#>><^<>.v.><^.^^..^<v.v><v^<<v>^<><^>^..<vv>><^^>v^>.^><v>v^v>>>>vv<<>><v^<<^^v^vv<.>vv^><v^.^v>...v>#
#>vv<v<><v>v>v>><^>>.<^<<^<^>^.^v>>vv^vv<^v><>>v^<^v.v^<v<vv^v><.^^>><.v^^><<^<><^>>vv^.><vv^<>>v.><<#
#<^<^<>v^v^^^<<v<>vv<<<.v<v^v^^><.>^.v.>vvv>^<<<v>^^>.^<<.v<v>^v..v<<<<<^^v^v^<>^>>^.>^<^v<.v..^v^>^>#
#<<^^<>^^><v>v.<<><<<v<^<^>^<<^v<<>^^<.^^^^<>^>><^>.v^v>v.<.^<<vv^^>>>^v<v<<vv^><<.<>>><.v<^^>>^v>^^<#
#>v><>..v^>v>^<<^>vv>.^v^v>>v^^^>><><<>v^.vv^.<><v>^^v^>.<^><<^^>>v^.^^^>v.<>^^<^>>^<^<<<^>^<>>^<<v<>#
#>vv<.vv><>^>>>>.<>.>v^>>v><<<v<.v^v>v^<v^<>>vv><.<><v>^>^<^^v^>v^<><>^^^>^<<^^.>..>.>^>^>>^>v>v<v<><#
#<>>v^>^<.v^^.^<vv^<>^>^^<^.^.>^<<^>><^vv><.v><^vv^^^^^v><><vv.v.>.^^v^v.>^v.<><v>>v>vv^.vv^^<>^>.><<#
#>>>>>>>.v<>^<^.>><v^^<v.<^<^>vv.^v>^>.>^>>^>>v^>v>.v.><<^^<^<vv.vv<vvvvv^^v><^^^>>><^>>v<v>>>v<^^.^>#
#>^^^^<<v^^^...^<v>>^^v^^><<.<><>^v^v^>>>^^>.v<v.v<v^^v<vv>v>vv>^v^<>^vv^vv.^vv>v^v>v>>.<>>><^^<^^>^<#
#<^^^<v>^.<>^>^<^<v>vv<vv<^vv^^<><v^>v>^.><^^v<>><>vvvv^>^^<<^v><<v^v<><^<<>^.v<><vv<><>>^.>v>vv>><^<#
#>v^^^^><^<vv<^<v>v.<^.><.^>>^<>v.<<^<>.>vv<<.vv.v>v^.<^<^^>>^.><>v<v<v>v<v>>vv>^<><^<v>>><v>><<vvv^.#
#>><>><^^<^^>v<^.^>><<v<^v<>v>v^<<<<^^.v>v^.>v^<^><^v<v.>><v<^>^^>^^^^.<v>^>.v^<^^<<><>.<v^v>^^>v<^.<#
#><v>v^^<>.vvv>>.<..^^.<<^>>v^<>.<v<<vv><v<^v.^>>>v>.<^>.vvv<v<^<^^>^>v>v<>v<^v<vv^>v<<<<<>.^v^^.>><.#
#<>>.<>^^>>><>>^<><<^^v^><v><<<<v>>^<^vv<<.v^<<<^>v>v^<^.<<<<^<^v^>vv.<.^><v<.^^<^>^.>^v^v>^>^<^.v><.#
#<^<.<^^<>^v<^<^>^>^.>.<<^.v<>v^^>>..v^v<.>^>^.^^v>^v^>vv>>^<^>>>^>><<v><><<v^<>>v.vv><>.><^.v<^<v<<>#
#<v^.v<>^^>v>.vv><>^v<^<^.<^>>v^^.><^<v<>v<<vv<>.<>v<v<>.>^^.v.^v><^^.^v<vv<<^<>>v.>^^.>^^><>>>>.^^.<#
#<>^<>^><.^^^v<^v^>v.>^<>^^v<vv^><v^^>^.><>^v<v>v<>.^><^^>^v<<.>>^^<.v<><vv>vv>>>v^v><v^<^<>v<^>>^<.<#
#>v^<v^>^>>^<^<^>v<^vvvv<<<vv<.><^<.^^>.>^.v<v<><<.<v>v^vv<>^<v<^<>>.^<>^v<vv<<><<.<^><v<<^><^<><<>^>#
#<<><..v<^v<>^.v>v^.<v.><>>v>>vv>v^^^><vvv<.>^^<v<vv<<v<.^^^..^<<<^^v^>><>>^v>v><<>^^v..>^<^vv^<v><^<#
#><>vv<<<.vv>^^<v>^<^<vvv^v<<<<<^v<.>>^><^v>vv><v>>>^^^<v.><>><<v^^.vv.^v><<<<<<^>^v>>.>>v.>v^<<>^v^.#
#.^>>>vv>vv>^^v>>^.<v>^v.>^>..<v.><^<^>.^<v^<>^v^v^>vv<>v^^><<.^>>^..<^^>><.vv>>v^<v><<^v>>>>v><>.^v>#
#>^^^>v<><><v>>>^^vv^^^v.v><v<>>^v^v^^>^v.>vv..^>>^v^<.^<<v<>^v<^<..^v>^<^^^v.v^>^^<>v><^<.^<v^.v.v>>#
#>v>v>>>vvvv<>>v^><>v<v^.^>>v>.v^vv.^^v.^>>>^^^>v.v<^>>v<v<>^^v^^>^<v..v^<^>^v^vv<<v><vv.v^v.vv>v<^.>#
#><^<>v^>>^><>vv>v^><<v<.>^.v^><<<^v>^>.v<<>^vvvv>.vv^v.><<^<v^.<.vv.vv^^>v^>v>>v^v><<v<^<v<><^v<>^^<#
#<vv^^>v>v<^>.<>..>>vv^^v^<vv>^.>^<^><v><^>>>><.^>v^<v^>v^<>.<.>.<<^<v>><v>>vvv<>.v^<>vvvv>v<.>^vv^v>#
#>.<^<<^<>^v.^v^>v^<<>^^>^<.vvvv<^<.v^<>v>><v^^.v^v^<>><.^<v<<>.>v^>^><.>^>>.v^.^..^<v^^v^vv<^v.><<>>#
#<>>>v<vv.^v>v^.v<<v<><v..v>vv^^v^<vv>><<v<v^>v<.>^.^v^<.>><><>^<>>vv>^>.>v><><^vv>>v>^^<<..><.>.>^.>#
####################################################################################################.#`;

const dirs = [
  [-1, 0], // 0 = up
  [0, 1], // 1 = right
  [1, 0], // 2 = down
  [0, -1], // 3 = left
  [0, 0],
];
const arrows = ["^", ">", "v", "<"];

function make_hash(pos) {
  return `${pos[0]},${pos[1]}`;
}

function unhash(hash) {
  const xs = hash.split(",");
  return [+xs[0], +xs[1]];
}

class Board {
  blizzards;
  walls;
  width;
  height;

  constructor(lines) {
    this.blizzards = [];
    this.walls = new Set();
    this.height = lines.length;
    this.width = lines[0].length;
    for (let i = 0; i < this.height; i++) {
      for (let j = 0; j < this.width; j++) {
        if (lines[i][j] === "#") {
          this.walls.add(make_hash([i, j]));
        } else if (lines[i][j] !== ".") {
          const dir = arrows.indexOf(lines[i][j]);
          this.blizzards.push([[i, j], dir]);
        }
      }
    }
  }

  // move onto the next minute
  advance() {
    // we advance all the blizzards forward by one position
    for (let i = 0; i < this.blizzards.length; i++) {
      const [pos, dir] = this.blizzards[i];
      const diff = dirs[dir];
      pos[0] += diff[0];
      pos[1] += diff[1];
      // however, we could have just hit a wall!
      if (this.walls.has(make_hash(pos))) {
        // if so, we backtrack to the wall in the opposite direction
        do {
          pos[0] -= diff[0];
          pos[1] -= diff[1];
        } while (!this.walls.has(make_hash(pos)));
        // once we hit a wall, we advance to find the next empty square
        pos[0] += diff[0];
        pos[1] += diff[1];
      }
    }
  }

  isBlizzard(pos) {
    return typeof this.blizzards.find(
      blizzard => make_hash(blizzard[0]) === make_hash(pos)
    ) !== "undefined";
  }

  isWall(pos) {
    return this.walls.has(make_hash(pos));
  }

  inBounds(pos) {
    if (pos[0] < 0 || pos[1] < 0) return false;
    if (pos[0] >= this.height || pos[1] >= this.width) return false;
    return true;
  }
}

// examine input; create board; find start and end points
const lines = sample.split("\n");
const board = new Board(lines);
const start = [0, lines[0].indexOf(".")];
const end = [lines.length - 1, lines[lines.length - 1].indexOf(".")];
const start_hash = make_hash(start);
const end_hash = make_hash(end);

// perform bfs
function bfs(from, to) {
  let curr = new Set([from]);
  let n = 0;
  while (!curr.has(to)) {
    n++;
    board.advance();
    const next = new Set();
    for (const hash of curr) {
      const pos = unhash(hash);
      for (const diff of dirs) {
        const new_pos = [pos[0] + diff[0], pos[1] + diff[1]];
        const hash = make_hash(new_pos);
        if (board.inBounds(new_pos) && !board.isWall(new_pos) && !board.isBlizzard(new_pos)) {
          next.add(hash);
        }
      }
    }
    curr = next;
    console.debug(`${n} done`);
  }
  return n;
}

// timing (1)
const before = process.hrtime();
const n1 = bfs(start_hash, end_hash); // start->end
const n2 = bfs(end_hash, start_hash); // end->start
const n3 = bfs(start_hash, end_hash); // start->end
const after = process.hrtime(before);

console.log(`It took ${n1}min from start->end!`);
console.log(`It took ${n2}min from end->start!`);
console.log(`It took ${n3}min from start->end!`);
console.log(`It took ${n1 + n2 + n3}min from start->end->start->end!`);
console.log(`Time: ${after[0] * 1000 + (after[1] / 1e6)}ms`)
